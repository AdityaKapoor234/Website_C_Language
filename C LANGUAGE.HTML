<HTML>
<HEAD>
<TITLE>
NIELIT
</TITLE>
</HEAD>
<BODY BGCOLOR="BLACK" TEXT="WHITE">

<CENTER>
<H1>
<FONT COLOR="RED" FACE="MISTRAL" SIZE="6">
<U><B>
C LANGUAGE
</B></U>
</FONT>
</H1>
</CENTER>
<FONT FACE="Lucida Handwriting">
<B>


<MARQUEE BGCOLOR="ORANGE">
<FONT COLOR="BROWN" SIZE="4">
C LANGUAGE HAS BEEN DEFINED SO THAT IT HAS THE ADVANTAGES OF A HIGH-LEVEL LANGUAGE NAMELY, MACHINE INDEPENDENCE.
</FONT>
</MARQUEE>

</BR></BR>
<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
C LANGUAGE
</U>
</FONT>


<OL>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
STRUCTURED LANGUAGE
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
ONE WAY TO ENTRY & EXIT
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
DIVIDE PROBLEM INTO SUB PROBLEM
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
GENERAL PURPOSE (FOR ALL WORK)
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
CASE SENSITIVE
</OL>






<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
FEATURES
</U>
</FONT>

<OL>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
C LANGUAGE PROVIDE THE FACILITY TO DO THE PROGRAMMING AT REGISTER LEVEL & THE REGISTER ARE DIRECTLY USED FOR VARIOUS OPERATIONS.</BR>THIS TYPE OF PROGRAMMING LEADS TO FASTER PROGRAMMING.
</BR>
</BR>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
C LANGUAGE TO ENGLISH LANGUAGE VARIOUS BUILD IN FUNCTION ARE AVAILABLE TO PERFORM REQUIRED OPERATION IN C LANGUAGE.</BR>IT IS INDEPENDENT OF THE CPU USED IN A MACHINE.
</BR>
</BR>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
C LANGUAGE FEATURE MAKE POSSIBLE DIVIDE & CONQUER APPROACH TO LARGE PROGRAMMING TASK. THESE PROGRAM ARE ORGANISED AS MODULES. EACH MODULE FOCUSING ON A SPECIFIC INSTRUCTION FOR A WELL DEFINED ACTIVITY. SO THEY CAN BE EASILY UNDERSTOOD AS COMPARE TO UNSTRUCTURED PROGRAM.
</BR>
</BR>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
C LANGUAGE IS A STRUCTURED PROGRAMMING THUS REQUIRED THE USER TO THINK OF PROBLEM IN TERMS OF MODULE. A PROPER COLLECTION OF THESE MODULE WILL MAKE A C PROGRAM. SO IT MAKE DEBUGGING, TESTING & MAINTENANCE EASY.
</BR>
</BR>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
C LANGUAGE IS EASY TO LEARN AND IT IS WIDELY USED FROM MICRO COMPUTER TO MAIN FRAME COMPUTER.
</BR>
</BR>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
IT COVERS ALL MOST ALL FUNTION OF ASSEMBLY LANGUAGE & IT IS ALSO EASY TO DEBUG & SHORT & TO THE POINT.
</BR>
</BR>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
C LANGUAGE IS A FUNCTION ORIENTED LANGUAGE ALL THE ADDITIONAL TASK SUCH AS INPUT, OUTPUT, GRAPHICS, ACCESS TO PERIPHERAL DEVICES, ETC ARE PLACED IN LIBRARY FUNCTIONS.
</BR>
</BR>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
POINTER FACILITY WHICH PROVIDE ACCESS TO THE ADDRESS OF A VARIABLE WHICH MAKES C LANGUAGE DIFFERENT FROM OTHER LANGUAGE SUCH AS FORTAN, COBOL.
</BR>
</BR>
</OL>



<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
2 PARTS OF C LANGUAGE-:</BR>
</U>
</FONT>


<UL>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
FLOW CHART
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
ALGORITHM
</UL>


<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
FLOW CHART
</U>
</FONT>
</BR></BR>

GRAPHICAL REPRESENTATION OF PROGRAM IS KNOWN AS FLOW CHART.

</BR></BR>

<CENTER>
<IMG SRC="FLOW CHART START END.PNG">
<IMG SRC="FLOW CHART INPUT OUTPUT.PNG">
<IMG SRC="FLOW CHART PROCESSING.PNG"></BR>

<IMG SRC="FLOW CHART DECISION MAKING.PNG">
</CENTER>






<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
ALGORITHM
</U>
</FONT>
</BR></BR>

STEP-WISE REPRESENTATION OF PROGRAM IS KNOWN AS ALGORITHM.

</BR></BR>














<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
PREPROCESSOR DIRECTIVE
</U>
</FONT>
</BR></BR>

THE PREPROCESSOR FOR 'C' IS A COLLECTION OF SPECIAL STATEMENTS, CALLED <I>DIRECTIVES</I>, WHICH ARE EXECUTED AT THE BEGINNING OF THE PROGRAM COMPILATION. THE COMMANDS FOR THE PREPROCESSOR ARE INSERTED IN 'C' SOURCE-CODE THAT IS (.c) FILES AND CALLED COMPILER DIRECTIVES. EACH COMPILER DIRECTIVE IS PREFIXED BY A HASH SIGN(#).

</BR></BR>

<FONT COLOR="GOLD">
<U>
USES OF PREPROCESSOR
</U>
</FONT>

</BR></BR>

THE C PREPROCESSOR PROVIDE SEVERAL TOOLS THAT ARE UNAVAILABLE IN OTHER HIGH LEVEL LANGUAGES. THE PROGRAMMER CAN USE THESE TOOLS TO MAKE HIS PROGRAM EASY TO READ, EASY TO MODIFY, PORTABLE AND MORE EFFICIENT.

</BR></BR>

<FONT COLOR="GOLD">
<U>
VARIOUS PREPROCESSOR DIRECTIVES
</U>
</FONT>

</BR></BR>

EXAMPLES OF PREPROCESSOR DIRECTIVES ARE #include, #define, #if, #else, #elif, #endif, #undef, etc.

</BR></BR>

<UL>
<FONT COLOR="PINK">
<U>
<LI>#define (MACRO DIRECTIVE)-:
</U>
</FONT>
</BR></BR>

'C' ALLOWS DEFINING AN IDENTIFIER HAVING CONSTANT VALUE USING #define DIRECTIVE. THIS IS CALLED A PRE-PROCESSOR DIRECTIVE AS IF IT IS NOT PART OF A C PROGRAM.

</BR></BR>

FOR EXAMPLE,

</BR></BR>

#define PI 3.14</BR>
#define MAX 100

</BR></BR>

IN A PROGRAM, THE VARIABLE PI WILL BE REPLACED BY ITS VALUE 3.14, WHICH IS DEFINED USING #define FUNCTION.

</BR></BR>

<FONT COLOR="PINK">
<U>
<LI>#include (FILE DIRECTIVE)
</U>
</FONT>
</BR></BR>

#include IS ALSO A PROCESSOR DIRECTIVE. THIS DIRECTIVE CAUSES ONE FILE TO BE INCLUDED IN ANOTHER

</BR></BR>
FOR EXAMPLE

</BR></BR>

#include < stdio.h >

</BR></BR>

WHICH APPEARS AT THE START OF THE PROGRAM.

</BR></BR>

<FONT COLOR="PINK">
<U>
<LI>#undef (MACRO DIRECTIVE)
</U>
</FONT>
</BR></BR>

SOMETIMES IT IS ESSENTIAL TO UNDEFINE A MACRO THAT IS ALREADY DEFINED. THIS CAN BE ACCOMPLISHED BY #undef DIRECTIVE. #undef REMOVES A MACRO DEFINATION FROM THE MACRO SYMBOL TABLE. A MACRO IS THEN NO LONGER DEFINED, UNLESS IT IS REDEFINED.

</BR></BR>

<FONT COLOR="PINK">
<U>
<LI>#conditional (COMPILATION DIRECTIVE)
</U>
</FONT>
</BR></BR>

THE PREPROCESSOR CONDITIONAL COMPILATION COMMAND ALLOWS LINES OF SOURCE TEXT TO BE PARSED THROUGH OR ELIMINATED BY THE PREPROCESSOR ON THE BASIS OF A COMPUTED CONDITION. SOME EXAMPLE OF PREPROCESSOR CONDITIONAL COMMANDS ARE #if, #else, #endif, #elif, etc.

</BR></BR>

THE #if  DIRECTIVE IS USED TO TEST WHEATHER AN EXPRESSION EVALUATES TO A NO-ZERO VALUE OR NOT.

</BR></BR>

THE #else HANDLES THE FALSE OR OTHERWISE CONDITION IF PRESENT AND #endif IS PROVIDED TO CORRESPOND WITH EACH PRIOR #if.

</BR></BR>

THE #elif COMMAND IS LIKE A COMBINATION OF THE #if AND #else. IT IS USED BETWEEN #if AND #endif IN THE SAME WAY AS #else BUT HAS A CONSTANT EXPRESSION TO EVALUATE.

</BR></BR>

</UL>


</BR></BR>




























<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
FUNCTION
</U>
</FONT>
</BR></BR>

A <I>FUNCTION</I> IS A ROUTINE OR SET OF INSTRUCTIONS, THAT PERFORMS A SPECIFIC TASK AND CAN BE PROCESSED INDEPENDENTLY. WHEN THE PROGRAM PASSES CONTROL TO A FUNCTION, THE FUNCTION PERFORMS THAT TASK AND RETURNS CONTROL TO THE INSTRUCTION FOLLOWING THE CALLING INTRUCTION. THE FUNCTION MAY PERFORM A STAND-ALONE TASK, SUCH AS INITIALIZING A SET OF VARIABLES OR IT MAY ACCEPTS VALUES (ARGUMENTS) FROM THE CALLING INSTRUCTION, PROCESS THEM AND PASS THE RESULTS BACK WHEN FINISHED.

</BR></BR>

<FONT COLOR="GOLD">
<U>
ADVANTAGE
</U>
</FONT>

</BR></BR>

<OL TYPE="A">
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>

THE COMPLEXITY OF THE ENTIRE PROGRAM CAN BE DIVIDED INTO SIMPLE SUBTASKS AND THEN FUNCTION SUBPROGRAMS CAN BE WRITTEN FOR EACH SUBTASKS (MODULAR PROGRAMMING).

</BR></BR>

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>

THE SUBPROGRAMS (WHICH ARE IN THE FORM OF FUNCTIONS) ARE EASIER TO WRITE, UNDERSTAND AND DEBUG.

</BR></BR>

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>

A FUNCTION CAN BE SHARED BY OTHER PROGRAMS BY COMPILING THE FUNCTION SEPERATELY AND LOADING AND LINKING THEM TOGETHER.

</BR></BR>

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>

IN 'C', A FUNCTION CAN CALL ITSELF AGAIN. IT IS CALLED A <I>RECURSIVE FUNCTION</I>. MANY CALCULATIONS CAN BE DONE EASILY USING RECURSIVE FUNCTIONS SUCH AS CALCULATION OF FACTORIAL OF A NUMBER, etc. IN SUCH A CASE, FUNCTION CAN CALL ITSELF.

</BR></BR>

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>

REDUCTION IN SIZE OF PROGRAM DUE TO PROGRAM CODE OF A FUNCTION CAN BE USED AGAIN AND AGAIN BY CALLING IT.

</BR></BR>

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>

A LIBRARY OF FUNCTIONS CAN BE DESIGNED AND TESTED FOR USE OF EVERY PROGRAMMER.

</OL>
</BR></BR>



















<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
VARIABLES
</U>
</FONT>
</BR></BR>


<TABLE WIDTH="100%">
<TR>
<TH>
<FONT COLOR="LIGHTGREEN">

</FONT>
</TH>
<TD>
<FONT COLOR="LIGHTGREEN">
<B>
DATA VARIABLE TYPE
</B>
</FONT>
</TD>
<TD>
<FONT COLOR="LIGHTGREEN">
<B>
SYNTEXT
</B>
</FONT>
</TD>
<TD>
<FONT COLOR="LIGHTGREEN">
<B>
BYTES
</B>
</FONT>
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
1)
</FONT>
</TH>
<TD>
CHARCTER ('A','B','C')
</TD>
<TD>
char a='c'
</TD>
<TD>
1
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
2)
</FONT>
</TH>
<TD>
INTEGER (1,2,3)
</TD>
<TD>
int a=1
</TD>
<TD>
2
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
3)
</FONT>
</TH>
<TD>
FLOAT (1.0,2.009)
</TD>
<TD>
float a=0.9
</TD>
<TD>
4
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
4)
</FONT>
</TH>
<TD>
DOUBLE (2.00000009)
</TD>
<TD>
double A=2.00000009
</TD>
<TD>
8
</TD>
</TR>
</TABLE>
</BR></BR>




















<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
DATA TYPES
</U>
</FONT>
</BR></BR>

<TABLE WIDTH="100%" CELLSPACING="10">
<TR>
<TH>
<FONT COLOR="LIGHTGREEN">
TYPE
</FONT>
</TH>
<TH COLSPAN="2">
<FONT COLOR="LIGHTGREEN">
RANGE
</FONT>
</TH>
<TH>
<FONT COLOR="LIGHTGREEN">
BYTES
</FONT>
</TH>
<TH>
<FONT COLOR="LIGHTGREEN">
REPRESENTS
</FONT>
</TH>
</TR>
<TR>
<TH>
<FONT COLOR="LIGHTGREEN">

</FONT>
</TH>
<TH>
<FONT COLOR="LIGHTGREEN">
FROM
</FONT>
</TH>
<TH>
<FONT COLOR="LIGHTGREEN">
TO
</FONT>
</TH>
<TH>
<FONT COLOR="LIGHTGREEN">

</FONT>
</TH>
<TH>
<FONT COLOR="LIGHTGREEN">

</FONT>
</TH>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
char/short
</FONT>
</TH>
<TH>
-128
</TH>
<TH>
127
</TH>
<TH>
1
</TH>
<TH>
characters
</TH> 
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
unsigned char
</FONT>
</TH>
<TH>
0
</TH>
<TH>
255
</TH>
<TH>
1
</TH>
<TH>
characters
</TH> 
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
int
</FONT>
</TH>
<TH>
-32,768
</TH>
<TH>
32,767
</TH>
<TH>
2
</TH>
<TH>
whole numbers
</TH> 
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
unsigned int
</FONT>
</TH>
<TH>
0
</TH>
<TH>
65,535
</TH>
<TH>
2
</TH>
<TH>
whole numbers
</TH> 
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
long
</FONT>
</TH>
<TH>
-2,147,438,648
</TH>
<TH>
2,147,438,647
</TH>
<TH>
4
</TH>
<TH>
whole numbers
</TH> 
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
unsigned long
</font>
</TH>
<TH>
0
</TH>
<TH>
4.294,967,295
</TH>
<TH>
4
</TH>
<TH>
whole numbers
</TH> 
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
float
</FONT>
</TH>
<TH>
3.4 x 10<sup>-38</sup>
</TH>
<TH>
3.4 x 10<sup>38</sup>
</TH>
<TH>
4
</TH>
<TH>
fractional number
</TH> 
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
double
</FONT>
</TH>
<TH>
1.7 x 10<sup>-308</sup>
</TH>
<TH>
1.7 x 10<sup>308</sup>
</TH>
<TH>
8
</TH>
<TH>
fractional number
</TH> 
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
long double
</FONT>
</TH>
<TH>
3.4 x 10<sup>-4932</sup>
</TH>
<TH>
3.4 x 10<sup>4932</sup>
</TH>
<TH>
10
</TH>
<TH>
fractional number
</TH> 
</TR>
</TABLE>



</BR></BR>

















<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
TESTING V/S DEBUGGING
</U>
</FONT>
</BR></BR>


<TABLE WIDTH="100%" CELLSPACING="10">
<TR>
<TH>
<FONT COLOR="LIGHTGREEN">

</FONT>
</TH>
<TH>
<FONT COLOR="LIGHTGREEN">
<B>
TESTING
</B>
</FONT>
</TH>
<TH>
<FONT COLOR="LIGHTGREEN">
<B>
DEBUGGING
</B>
</FONT>
</TH>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
1)
</FONT>
</TH>
<TD>
TESTING IS THE PROCESS IN WHICH A POGRAM IS VALIDATED.
</TD>
<TD>
DEBUGGING IS THE PROCESS IN WHICH PROGRAM ERRORS ARE REMOVED.
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
2)
</FONT>
</TH>
<TD>
TESTING IS COLMPLETE WHEN ALL DESIRED VERIFICATIONS IN TERMS OF THE SPECIFICATIONS HAVE BEEN PERFORMED.
</TD>
<TD>
DEBUGGING IS A PROCESS THAT ENDS ONLY TEMPORARILY, BECAUSE SUBSEQUENT EXECUTION OF A PROGRAM MAY UNCOVER OTHER ERRORS-THEREBY RESTARTING THE DEBUGGING PROCESS.
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
3)
</FONT>
</TH>
<TD>
TESTING CAN AND SHOULD BE PLANNED. IT IS A DEFINABLE TASK IN WHICH THE HOW & WHAT TO TEST CAN BE SPECIFIED. TESTING CAN BE SCHEDULED TO TAKE PLACE AT A SPECIFIC TIME IN THE DEVELOPMENT CYCLE.
</TD>
<TD>
DEBUGGING IS A REACTIVE PROCEDURE WHICH STEMS FROM TESTING. IT CANNOT BE PLANNED AHEAD OF TIME. THE BEST THAT CAN BE DONE IS TO ESTABLISH GUIDELINES OF HOW TO DEBUG & DEVELOP A LIST OF "WHAT TO LOOK FOR".
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
4)
</FONT>
</TH>
<TD>
TESTING CAN BEGIN IN THE EARLY STAGES OF THE DEVELOPMENT EFFORT. OF COURE THE TESTS THEMSELVES MUST BE RUN NEAR THE END OF A PROJECT, BUT THE DECISIONS OF WHAT TO TEST , HOW TO TEST, WITH WHAT KIND OF DATA CAN & SHOULD BE COMPLETED BEFORE THE CODING IS STARTED.
</TD>
<TD>
DEBUGGING, ON THE OTHER HAND, CANNOT BEGIN UNTILL THE END OF THE DEVELOPMENT CYCLE, BECAUSE IT REQUIRES AN EXECUTABLE PROGRAM.
</TD>
</TR>
</TABLE>
</BR></BR>




















<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
FORMAT SPECIFIERS
</U>
</FONT>
</BR></BR>

<TABLE WIDTH="100%" CELLSPACING="10">
<TR>
<TD>
<FONT COLOR="LIGHTGREEN">
<B>FORMAT SPECIFIERS</B>
</FONT>
</TD>
<TD>
<FONT COLOR="LIGHTGREEN">
<B>DESCRIPTION</B>
</FONT>
</TD>
</TR>
<TR>
<TD>
<FONT COLOR="GOLD">
<B>%c</B>
</FONT>
</TD>
<TD>
A SINGLE CHARACTER
</TD>
</TR>
<TR>
<TD>
<FONT COLOR="GOLD">
<B>%d</B>
</FONT>
</TD>
<TD>
A DECIMAL INTEGER
</TD>
</TR>
<TR>
<TD>
<FONT COLOR="GOLD">
<B>%f</B>
</FONT>
</TD>
<TD>
A FLOATING POINT NUMBER
</TD>
</TR>
<TR>
<TD>
<FONT COLOR="GOLD">
<B>%h</B>
</FONT>
</TD>
<TD>
A SHORT INTEGER
</TD>
</TR>
<TR>
<TD>
<FONT COLOR="GOLD">
<B>%o</B>
</FONT>
</TD>
<TD>
AN OCTAL NUMBER
</TD>
</TR>
<TR>
<TD>
<FONT COLOR="GOLD">
<B>%s</B>
</FONT>
</TD>
<TD>
A STRING
</TD>
</TR>
<TR>
<TD>
<FONT COLOR="GOLD">
<B>%x</B>
</FONT>
</TD>
<TD>
A HEXADECIMAL NUMBER
</TD>
</TR>
</TABLE>
</BR></BR>






















<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
FORMAT CODE
</U>
</FONT>
</BR></BR>

<TABLE WIDTH="100%" CELLSPACING="10">
<TR>
<TH COLSPAN="2">
<FONT COLOR="LIGHTGREEN">
DATA TYPE
</FONT>
</TH>
<TH>
<FONT COLOR="LIGHTGREEN">
CONVERSION CHARACTER
</FONT>
</TH>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
INTEGER
</FONT>
</TH>
<TH>
short signed</br>
short unsigned</br>
long signed</br>
long unsigned
</TH>
<TH>
%d or %i</br>
%u</br>
%ld</br>
%lu</br>
</TH>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">

</FONT>
</TH>
<TH>
unsigned hexadecimal</br>
unsigned octal
</TH>
<TH>
%x</br>
%o
</TH>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
REAL
</FONT>
</TH>
<TH>
float</br>
double
</TH>
<TH>
%f</br>
%lf
</TH>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
CHARACTER
</FONT>
</TH>
<TH>
signed character</br>
unsigned character
</TH>
<TH>
%c</br>
%c
</TH>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
STRING
</FONT>
</TH>
<TH>

</TH>
<TH>
%s
</TH>
</TR>
<TABLE>
</BR></BR>





















<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
PRECEDENCE OF OPERATORS USED IN 'C'
</U>
</FONT>
</BR></BR>

<TABLE WIDTH="100%" CELLSPACING="10">
<TR>
<TD>
<FONT COLOR="LIGHTGREEN">
<B>OPERATOR</B>
</FONT>
</TD>
<TD>
<FONT COLOR="LIGHTGREEN">
<B>ASSOCIATIVITY</B>
</FONT>
</TD>
<TD>
<FONT COLOR="LIGHTGREEN">
<B>PRECEDENCE</B>
</FONT>
</TD>
</TR>
<TR>
<TD>
() [] -> -
</TD>
<TD>
LEFT TO RIGHT
</TD>
<TD ROWSPAN="15">
<IMG SRC="PRECEDENCE.JPG">
</TD>
</TR>
<TR>
<TD>
! ~ ++ -- - & * (typecast) sizeof
</TD>
<TD>
RIGHT TO LEFT
</TD>
</TR>
<TR>
<TD>
* / %
</TD>
<TD>
LEFT TO RIGHT
</TD>
</TR>
<TR>
<TD>
+ -
</TD>
<TD>
LEFT TO RIGHT
</TD>
</TR>
<TR>
<TD>
<< >>
</TD>
<TD>
LEFT TO RIGHT
</TD>
</TR>
<TR>
<TD>
< <= > >=
</TD>
<TD>
LEFT TO RIGHT
</TD>
</TR>
<TR>
<TD>
== !=
</TD>
<TD>
LEFT TO RIGHT
</TD>
</TR>
<TR>
<TD>
&
</TD>
<TD>
LEFT TO RIGHT
</TD>
</TR>
<TR>
<TD>
^
</TD>
<TD>
LEFT TO RIGHT
</TD>
</TR>
<TR>
<TD>
|
</TD>
<TD>
LEFT TO RIGHT
</TD>
</TR>
<TR>
<TD>
&&
</TD>
<TD>
LEFT TO RIGHT
</TD>
</TR>
<TR>
<TD>
||
</TD>
<TD>
LEFT TO RIGHT
</TD>
</TR>
<TR>
<TD>
?:
</TD>
<TD>
RIGHT TO LEFT
</TD>
</TR>
<TR>
<TD>
= += -= *= /=
</TD>
<TD>
RIGHT TO LEFT
</TD>
</TR>
<TR>
<TD>
,
</TD>
<TD>
LEFT TO RIGHT
</TD>
</TR>
</TABLE>
</BR></BR>








































<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
STORAGE CLASS
</U>
</FONT>
</BR></BR>



THE PERIOD OF TIME DURING WHICH MEMORY IS ASSOCIATED WITH A VARIABLE IS CALLED THE EXTENT OF THE VARIABLE. IT IS CHARACTERZIED BY STORAGE CLASSES. EVERY C VARIABLE POSSESSES A CHARACTERISTIC CALLED ITS SORAGE CLASS.</BR></BR>
 THERE ARE FOUR CLASS SPECIFIERS. THESE ARE-:

<OL TYPE="A">
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
AUTO

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
STATIC

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
REGISTER

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
EXTERN

</OL>


<UL>
<FONT COLOR="PINK">
<U>
<LI>AUTO-:
</U>
</FONT>
</BR></BR>

BY DEFAULT, PARAMETERS USED IN A FUNCTION AS WELL AS VARIABLES DECLARED INSIDE A FUNCTION BELONG TO THE <I>automatic storage class</I>. THESE VARIABLES HAVE local VISIBILITY OR SCOPE. THAT IS IF YOU DECLARE A VARIABLE CALLED tina IN main() AND DECLARE ANOTHER VARIABLE WITH THE SAME NAME IN A FUNCTION CALLED om(), YOU HAVE CREATED two INDEPENDENT VARIABLES, EACH KNOWN ONLY IN THE FUNCTION IN WHICH IT IS DEFINED. ANYTHING YOU DO TO THE VARIABLE tina IN om() HAS NO EFFECT ON THE tina IN main() AND VICE VERSA. ALSO, EACH VARIABLE ALLOCATED WHEN ITS FUNCTION BEGINS EXECUTION AND EACH FADES AWAY FROM EXISTENCE WHEN THAT FUNCTION WHERE IT IS DEFINED TERMINATES.

</BR></BR>

PROGRAM SHOWS THE WORKING OF auto VARIABLE.

</BR></BR>

void auto (void);</BR>
main()</BR>
{</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	int i;</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	for (i=1 ; i<=3 ; i++)</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		increment();</BR>
}</BR></BR>
void auto (void)</BR>
{</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	auto int x=0;</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	x=x+1;</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	printf(" x = %d\n",x);</BR>
}</BR></BR>

<u>RUN</u></BR>
x=1</BR>
x=1</BR>
x=1

</BR></BR>

<FONT COLOR="PINK">
<U>
<LI>STATIC-:
</U>
</FONT>
</BR></BR>
A STATIC VARIABLE IS KNOWN ONLY TO THE FUNCTION IN WHICH IT IS DEFINED. HOWEVER, UNLIKE AUTOMATIC VARIABLES, IT DOES NOT DISAPPEAR WHEN THE FUNCTION TERMINATES. INSTEAD IT KEEPS ITS PLACE AND VALUE IN MEMORY. A VARIABLE CAN BE DECLARED STATIC USING THE KEYWORD <I>static</I>.</BR></BR>

PROGRAM SHOWS THE PROPERTIES OF A STATIC VARIABLE.
</BR></BR>

#include < stdio.h ></br>
void increment (void);</br>
main()</br>
{</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	int i;</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	for (i=1 ; i<=3 ; i++)</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
		increment();</br>
}</br></BR>
void increment (void)</br>
{</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	static int x=0;</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	x=x+1;</br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	printf(" x = %d\n",x);</br>
}</br></br>

<U>RUN</U></br>
x=1</br>
x=2</br>
x=3

</BR></BR>


<FONT COLOR="PINK">
<U>
<LI>REGISTER-:
</U>
</FONT>
</BR></BR>
THE <I>register</I> KEYWORD MAY BE USED ONLY FOR VARIABLES DECLARED WITHIN A FUNCTION. IT MAKES THE VARIABLE AUTOMATIC BUT ALSO PASSES A HINT TO THE COMPILER TO STORE THE VARIABLE IN A REGISTER WHENEVER POSSIBLE. YOU SHOULD USE THE  register KEYWORD FOR AUTOMATIC VARIABLES THAT ARE ACCESSED FREQUENTLY. A GOOD EXAMPLE OF FREQENTLY USE VARIABLES IS LOOP COUNTERS.  THIS IS DONE AS FOLLOWS-:</BR></BR>
register int count;
</BR></BR>

<FONT COLOR="PINK">
<U>
<LI>EXTERN-:
</U>
</FONT>
</BR></BR>

THE extern SPECIFIER MAY BE USED FOR DECLARING VARIABLES WITHIN AS WELL AS OUTSIDE A FUNCTION (EXCEPT FOR FUNCTION ARGUMENTS). WHEN A PROGRAM SPANS ACROSS DIFFERENT FILES, THEY CAN SHARE INFORMATION USING GLOBAL VARIABLES. GLOBAL VARIABLES MUST BE DEFINED ONLY ONCE IN ANY OF THE PROGRAM MODULE AND THEY CAN BE ACCESSED BY ALL OTHERS. SO, USE extern STORAGE CLASS FOR THOSE VARIABLES THAT ARE BEING USED BY ALMOST ALL THE FUNCTIONS IN THE PROGRAM.

</BR></BR>

</UL>

</BR></BR>



























<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
ESCAPE SEQUENCE
</U>
</FONT>
</BR></BR>

<TABLE WIDTH="100%" CELLSPACING="10">
<TR>
<TD>
<FONT COLOR="LIGHTGREEN">
ESC. SEQ
</FONT>
</TD>
<TD>
<FONT COLOR="LIGHTGREEN">
PURPOSE
</FONT>
</TD>
</TR>
<TR>
<TD>
\n
</TD>
<TD>
NEW LINE
</TD>
</TR>
<TR>
<TD>
\b
</TD>
<TD>
BACKSPACE
</TD>
</TR>
<TR>
<TD>
\f
</TD>
<TD>
FORM FEED
</TD>
</TR>
<TR>
<TD>
\'
</TD>
<TD>
SINGLE QUOTE
</TD>
</TR>
<TR>
<TD>
\\
</TD>
<TD>
BACKSLASH
</TD>
</TR>
<TR>
<TD>
\t
</TD>
<TD>
TAB
</TD>
</TR>
<TR>
<TD>
\r
</TD>
<TD>
CARRIAGE RETURN
</TD>
</TR>
<TR>
<TD>
\a
</TD>
<TD>
ALERT
</TD>
</TR>
<TR>
<TD>
\"
</TD>
<TD>
DOUBLE QUOTE
</TD>
</TR>
</TABLE>
</BR></BR>























<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
SWITCH CASE V/S IF-ELSE
</U>
</FONT>
</BR></BR>

<TABLE WIDTH="100%" CELLSPACING="10">
<TR>
<TH>
<FONT COLOR="LIGHTGREEN">

</FONT>
</TH>
<TH>
<FONT COLOR="LIGHTGREEN">
SWITCH CASE
</FONT>
</TH>
<TH>
<FONT COLOR="LIGHTGREEN">
IF-ELSE
</FONT>
</TH>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
1)
</FONT>
</TH>
<TD>
SWITCH STATEMENT IS VERY USEFUL WHILE WRITING MENU DRIVEN PROGRAM.
</TD>
<TD>
IF-ELSE STATEMENT IS NOT AS MUCH COMPACT AS COMPARE TO SWITCH STATEMENT
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
2)
</FONT>
</TH>
<TD>
THE SWITCH STATEMENT LEADS TO A MORE STRUCTURED PROGRAM AND THE LEVEL OF INDENTATION IS MANAGEABLE.
</TD>
<TD>
THE IF-ELSE STATEMENT IS DIFFICULT TO BE MANAGED WHEN THERE ARE MORE THAN TWO OPTION FOR A CONDITION TO BE CHOOSE FOR.
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
3)
</FONT>
</TH>
<TD>
EVEN IF THERE ARE MUTIPLE CONDITION TO BE EXECUTED IN EACH CASE THERE IS NO NEED TO ENCLOSE THEM WITHIN A PAIR OF BRACES.
</TD>
<TD>
EVEN IF THERE ARE MUTIPLE CONDITION TO BE EXECUTED IN EACH IF-ELSE STATEMENT THEY SHOULD BE ENCLOSE WITHIN A PAIR OF BRACES.
</TD>
</TR>
</TABLE>

</BR></BR>















<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
ARRAY
</U>
</FONT>
</BR></BR>

AN ARRAY IS A COLLECTION OF SIMILAR DATA TYPES OR ELEMENTS, ADDRESSED BY A COMMON VARIABLE NAME.

</BR></BR>

<FONT COLOR="PINK">
<U>
Syntax-:
</U>
</FONT>

int a[10];

</BR></BR>

<FONT COLOR="GOLD">
<U>
ADVANTAGE-:
</U>
</FONT>
</BR></BR>

<OL>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
IT IS USED TO REPRESENT MULTIPLE DATA ITEMS OF SAME TYPE BY USING ONLY SINGLE NAME.

</BR></BR>

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
IT CAN BE USED TO IMPLEMENT OTHER DATA STRUCTURES LIKE LINKED LISTS, STACKS, QUEUE, TREES, GRAPHS, etc.

</BR></BR>

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
2D ARRAYS ARE USED TO REPRESENT MATRICES.

</BR></BR>

</OL>



<FONT COLOR="GOLD">
<U>
DISADVANTAGE-:
</U>
</FONT>

<OL>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
WE MUST KNOW IN ADVANCE THAT HOW MANY ELEMENTS ARE TO BE STORED IN ARRAY.

</BR></BR>

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
ARRAY IS STATIC STRUCTURE. IT MEANS THAT ARRAY IS OF FIXED SIZE. THE MEMORY WHICH IS ALLOCATED TO ARRAY CAN NOT BE INCREASED OR REDUCED. 

</BR></BR>

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
SINCE ARRAY IS OF FIXED SIZE, IF WE ALLOCATE MORE MEMORY THAN REQUIREMENT THEN THE MEMORY SPACE WILL BE WASTED. AND IF WE ALLOCATE LESS MEMORY THAN REQUIREMENT, THEN IT WILL CREATE PROBLEM.

</BR></BR>

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
THE ELEMENTS OF ARRAY ARE STORED IN CONSECUTIVE MEMORY LOCATIONS. SO INSERTIONS AND DELETIONS ARE VERY DIFFICULT AND TIME CONSUMING.

</BR></BR>

</OL>





















<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
BINARY SEARCH V/S LINEAR SEARCH
</U>
</FONT>
</BR></BR>

<TABLE WIDTH="100%" CELLSPACING="10">
<TR>
<TH>
<FONT COLOR="LIGHTGREEN">

</FONT>
</TH>
<TH>
<FONT COLOR="LIGHTGREEN">
BINARY SEARCH
</FONT>
</TH>
<TH>
<FONT COLOR="LIGHTGREEN">
LINEAR SEARCH
</FONT>
</TH>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
1)
</FONT>
</TH>
<TD>
DATA MUST BE IN SORTED ORDER
</TD>
<TD>
DATA CAN BE IN ANY ORDER
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
2)
</FONT>
</TH>
<TD>
TIME COMPLEXITY IS O(log n)
</TD>
<TD>
TIME COMPLEXITY IS O(n)
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
3)
</FONT>
</TH>
<TD>
ACCESS IS FASTER
</TD>
<TD>
ACCESS IS SLOW
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
4)
</FONT>
</TH>
<TD>
BINARY SEARCH REQUIRES RANDOM ACCESS TO THE DATA
</TD>
<TD>
LINEAR SEARCH REQUIRES SEQUENTIAL ACCESS TO THE DATA
</TD>
</TR>
</TABLE>

</BR></BR>














<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
ARRAY V/S LINKED LIST
</U>
</FONT>
</BR></BR>

<TABLE WIDTH="100%" CELLSPACING="10">
<TR>
<TH>
<FONT COLOR="LIGHTGREEN">

</FONT>
</TH>
<TH>
<FONT COLOR="LIGHTGREEN">
ARRAY
</FONT>
</TH>
<TH>
<FONT COLOR="LIGHTGREEN">
LINKED LIST
</FONT>
</TH>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
1)
</FONT>
</TH>
<TD>
ARRAYS ARE LINEAR DATA STRUCTURE
</TD>
<TD>
LINKED LIST ARE LINEAR NON-LINEAR DATA STRUCTURE
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
2)
</FONT>
</TH>
<TD>
ARRAYS ARE STATICALLY ALLOCATED i.e. ARRAYS ARE STATIC/FIXED SIZE. ARRAY ELEMENTS CAN BE MODIFIED EASILY BY IDENTIFYING ITS INDEX NUMBER.
</TD>
<TD>
LINKED LIST ARE DYNAMICALLY ALLOCATED AND LINKED. WITH LISTS, YOU JUST CREATE AN EMPTY LIST AND FREELY EXPAND IT. GENERALLY, IF THE NUMBER OF ALLOCATION ARE KNOWN BEFORE HAND, WE USE ARRAYS OTHERWISE LINKED LIST.
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
3)
</FONT>
</TH>
<TD>
ARRAY IS A HIGH PERFORMANCE WAY OF STORING A GROUP OF DATA BECAUSE EACH ELEMENT IS LAID OUT NEXT TO IT'S NEIGHBOR IN MEMORY. HTIS ALLOWS FOR VERY FAST ACCESS
</TD>
<TD>
LIST IS A SEQUENCE OF NODES, CONNECTED BY NEXT POINTERS, SO CONSEQUENT NODES MAY LIE ANYWHERE IN MEMORY.
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
4)
</FONT>
</TH>
<TD>
ARRAYS ARE RANDOM ACCESS STRUCTURES, WHERE YOU CAN ACCESS ELEMENTS IN RANDOM/INDEXED MANNER.
</TD>
<TD>
LINKED LIST IS A SEQUENTIAL ACCESS STRUCTURE.
</TD>
</TR>
</TABLE>


</BR></BR>































































<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
CALLING A FUNTION
</U>
</FONT>
</BR></BR>


<FONT COLOR="GOLD">
2 TYPES OF CALLING-:</BR></BR>
</FONT>
<OL>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
CALLING

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
PROTOTYPE OR FORWARD DECLARATION
</OL>



<UL>
<FONT COLOR="PINK">
<U>
<LI>CALLING-:
</U>
</FONT>
</BR></BR>

IN CALLING THE ANOTHER USER DEFINED FUNCTION IS CALLED IN main() FUNCTION OR ANOTHER USER DEFINED FUNCTION. AND THE FUNCTION IN WHICH IT IS CALLED IS DEFINED BEFORE THE FUNCTION IN WHICH IT IS CALLED.

</BR></BR>

FOR EXAMPLE,

</BR></BR>

#include < stdio.h ></BR>
void abc(int n)</BR>
{</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
......</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
......</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
......</BR>
}</BR></BR>

void main()</BR>
{</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int n;</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
......</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
......</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
......</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
abc(n);</BR>
}

</BR></BR>

IN THIS EXAMPLE THE FUNCTION WHICH IS BEING CALLED abc() IS DEFINED BEFORE THE FUNCTION IN WHICH IT IS CALLED main(). THIS METHOD OF CALLING A USER DEFINED FUNCTION IS KNOWN AS CALLING.

</BR></BR>

<FONT COLOR="PINK">
<U>
<LI>PROTOTYPE OR FORWARD DECLARATION-:
</U>
</FONT>
</BR></BR>

IN PROTOTYPE/FORWARD DECLARATION THE ANOTHER USER DEFINED FUNCTION IS CALLED IN </BR>main() FUNCTION OR ANOTHER USER DEFINED FUNCTION. AND THE FUNCTION IN WHICH IT IS CALLED IS DEFINED AFTER THE FUNCTION IN WHICH IT IS CALLED.

</BR></BR>

FOR EXAMPLE,

</BR></BR>

#include < stdio.h ></BR>
void main()</BR>
{</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int n;</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
void abc(int n);</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
clrscr();</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
......</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
......</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
......</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
abc(n);</BR>
}</BR></BR>

void abc(int n)</BR>
{</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
......</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
......</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
......</BR>
}

</BR></BR>

IN THIS EXAMPLE THE FUNCTION WHICH IS BEING CALLED abc() IS DEFINED AFTER THE FUNCTION IN WHICH IT IS CALLED main(). IN THIS CASE A ADDITIONAL STATEMENT IS ALSO USED </br>(void abc(int n);) BEFORE THE clrscr(); FUNCTION WITH THE CALLING STATEMENT KNOWN AS PROTOTYPE/FORWARD DECLARATION.

</BR></BR>
</UL>



<FONT COLOR="GOLD">
2 TYPES OF VARIABLE PASSING IN OTHER FUNCTION IN CALLING A FUNCTION-:</BR></BR>
</FONT>
<OL>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
CALL BY VALUE

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
CALL BY REFFERENCE
</OL>

<UL>
<FONT COLOR="PINK">
<U>
<LI>CALL BY VALUE-:
</U>
</FONT>
</BR></BR>
IN C, ARGUMENT ARE PASSED BY THE VALUE, WHICH MEANS THAT A COPY OF THE ARGUMENT IS PASSED TO THE FUNCTION. THE FUNCTION CAN CHANGE THE VALUE OF THIS COPY BUT CANNOT CHANGE THE VALUE OF THE ARGUMENT IN THE CALLING FUNCTION.
</BR></BR>

<IMG SRC="CALL BY VALUE.PNG" HEIGHT="40%" WIDTH="100%">

</BR></BR>
IN THE <U><I>CALL BY VALUE</I></U> METHOD, THE FORMAL ARGUMENT IS A COPY OF ACTUAL ARGUMENT. TO UNDERSTAND IT CLEARLY TAKE ONE REAL LIFE EXAMPLE. SUPPOSE YOUR ENGLISH TEACHER HAS GIVEN YOU ONE PRINTED PASSAGE  WITH GRAMMATICAL ERRORS AND SPELLING MISTAKES ON A SHEET OF PAPER AND WANTED YOU TO NOTE DOWN THE SAME PASSAGE IN YOUR TEST NOTEBOOK AND THEN DO CORRECTIONS WHEREVER YOU FIND ANY GRAMMATICAL ERROR OR SPELLING MISTAKES. HERE, PRINTED SHEET WITH ERROR REPRESENTS THE ACTUAL PARAMETER AND YOUR TEST NOTEBOOK, WHERE YOU COPIED DOWN THE PASSAGE REPRESENTS THE FORMAL PARAMETER; WHAT EVER CHANGES YOU MADE IN YOUR NOTEBOOK WOULD NOT REFLECT ANY CHANGE TO YOUR TEACHER'S ORIGINAL SHEET.

</BR></BR>
<HR>
THE ARGUMENT THAT IS PASSED IS OFTEN CALLED AN ACTUAL ARGUMENT AND WHILE THE RECEIVED COPY IS CALLED A FORMAL ARGUMENT OR FORMAL PARAMETER.
<HR>
</BR>
THUS,IN <U><I>CALL BY VALUE</I></U> METHOD, THE VALUES OF ACTUAL PARAMETERS ARE PASSED ON TO FORMAL PARAMETERS AND THE CHANGES MADE IN THE VALUES IN THE FORMAL PARAMETERS ARE NOT REFLECTED BACK INTO THE ACTUAL PARAMETERS OF CALLING FUNCTION.

</BR></BR>


<FONT COLOR="PINK">
<U>
<LI>CALL BY REFFERENCE-:
</U>
</FONT>
</BR></BR>

IF THE PROGRAMMER DESIRES THAT THE CHANGES MADE TO THE FORMAL PARAMETER(S) BE REFLECTED ON THE CORRESPONDING ACTUAL PARAMETER(S) THEN HE/SHE SHOULD USE <I>CALL BY REFFERENCE</I> METHOD FOR PARAMETER PASSING. THE TECHNIQUE PASSES THE ADDRESSES OF THE ACTUAL PARAMETERS TO THE CALLED FUNCTION. THUS, THE ACTUAL AND FORMAL PARAMETERS SHARE THE SAME MEMORY LOCATIONS. THIS IS ACHIEVED BY APPLYING AN ADDRESS OPERATOR, THAT IS THE OPERATOR (&), TO THE FORMAL PARAMETERS IN THE FUNCTION DEFINITION.

</BR></BR>
<IMG SRC="CALL BY REFFERENCE.PNG" WIDTH="100%">
</BR>

IN THE <I>CALL BY REFFERENCE</I>, THE ACTUAL AND FORMAL ARGUMENTS REFER TO THE SAME MEMORY LOCATION OR AREA.

</BR></BR>

THE ARROWS IN THE <I>CALL BY REFFERENCE</I> FIGURE ABOVE POINTS IN BOTH THE DIRECTION WHEREAS THE CALL BY VALUE ARROWS ARE SHOWN IN ONE DIRECTION.

</BR></BR>

TAKE AGAIN A REAL LIFE SITUATION TO UNDERSTAND THIS SITUATION. SUPPOSE IN YOUR COLLEGE, ALL THE LABS ARE NUMBERED AS 1 FOR CHEMISTRY LAB, 2 FOR PHYSICS LAB, 3 FOR BIOLOGY LAB AND 4 FOR COMPUTER LAB. NOW TO REFER TO ANY LAB YOU CAN EITHER SAY THE LAB NUMBER OR CALL IT BY ITS NAME. FOR EXAMPLE, YOU CAN REFER TO THE "COMUTER ROOM" BY EITHER GIVING THE ORIGINAL NAME AS "COMPUTER LAB" OR BY ITS REFERENCE "NO.4 LAB".

</UL>




</BR></BR>





















<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
MEMORY ALLOCATION
</U>
</FONT>
</BR></BR>

<FONT COLOR="GOLD">
THE MEMORY ALLOCATION MAY BE CLASSIFIED AS TWO TYPES-:</BR></BR>
</FONT>
<OL>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
STATIC ALLOCATION

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
DYNAMIC ALLOCATION
</OL>

<UL>
<FONT COLOR="PINK">
<U>
<LI>STATIC ALLOCATION-:
</U>
</FONT>
</BR></BR>

IN STATIC ALLOCATION, THE SIZE OF THE MEMORY MAY BE REQUIRED FOR THE CALCULATION THAT MUST BE DEFINED BEFORE LOADING AND EXECUTING THE PROGRAM, WHEREAS IN DYNAMIC ALLOCATION, THE REQUIRED MEMORY SIZE IS ALLOCATED WHILE PROGRAM IS GETTING EXECUTED.

</BR></BR>

<FONT COLOR="PINK">
<U>
<LI>DYNAMIC ALLOCATION-:
</U>
</FONT>
</BR></BR>

THERE ARE THREE DYNAMIC MEMORY ALLOCATION FUNCTIONS AND ONE MEMORY DEALLOCATION FUNCTION. THESE FUNCTIONS ARE-:

</BR></BR>

<OL TYPE="A">
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
malloc()

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
calloc()

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
realloc()

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
free()
</OL>

</BR></BR>

<UL>
<FONT COLOR="PINK">
<U>
<LI>malloc()-:
</U>
</FONT>
</BR></BR>

THE FUNCTION <I>malloc()</I> ALLOCATES A SPECIFIED NUMBER OF BYTES IN MEMORY. THE ALLOCATED REGION IS NOT FILLED WITH ZERO. THE STARTING ADDRESS IS RETURNED IF THE FUNCTION IS SUCCESFUL. A ZERO IS RETURNED IF THE FUNCTION FAILS TO ALLOCATE MEMORY. TO ASSIGN SUFFICIENT MEMORY FOR x, WE CAN MAKE USE OF THE LIBRARY FUNCTION malloc(),</BR> AS FOLLOWS-:

</BR></BR>

x=malloc(10*sizeof(int))

</BR></BR>

THIS FUNCTION RESERVES A BLOCK OF MEMORY WHOSE SIZE (in bytes) IS EQUIVALENT TO THE SIZE OF AN INTEGER.

</BR></BR>

<FONT COLOR="PINK">
<U>
<LI>calloc()-:
</U>
</FONT>
</BR></BR>

THIS IS SIMILAR TO malloc(), BUT INITIALIZES THE ALLOCATED BYTE TO ZERO. THIS FUNCTION ALSO ALLOWS YOU TO ALLOCATE MEMORY FOR MORE THAN ONE OBJECT AT A TIME. THE STARTING ADDRESS OF THE AREA IS RETURNED IF THE FUNCTION IS SUCCESSFUL. A ZERO IS RETURNED IF THE FUNCTION'S ATTEMPT TO GET A BLOCK OF MEMORY FAILS.

</BR></BR>

THE GENERAL DECLARATION OF THE calloc() FUNCTION IS-:

</BR></BR>

char *calloc(elements,element_size)</br>
unsigned int element;</br>
unsigned int element_size;

</BR></BR>

<FONT COLOR="PINK">
<U>
<LI>realloc()-:
</U>
</FONT>
</BR></BR>

THE realloc() FUNCTION IS USED TO CHANGE THE SIZE OF THE PREVIOUSLY ALLOCATED BLOCK.

</BR></BR>

THE GENERAL FORMAT OF THE realloc() FUNCTION IS-:

</BR></BR>

char *realloc(oldblock,size)</br>
char *oldblock;</br>
unsigned int size;

</BR></BR>

<FONT COLOR="PINK">
<U>
<LI>free()-:
</U>
</FONT>
</BR></BR>

IT IS NECESSARY TO FREE THE MEMORY ALLOCATED SO THAT THE MEMORY CAN BE REUSED. THE free() FUNCTION FREES UP (DEALLOCATES) MEMORY THAT WAS PREVIOUSLY ALLOCATED WITH malloc(), calloc() OR realloc().

</BR></BR>

THE GENERAL FORMAT OF free() FUNCTION IS

</BR></BR>

int free(pointer)</br>
char *pointer;

</UL>



</UL>

</BR></BR>




















<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
LINKED LIST
</U>
</FONT>
</BR></BR>

<FONT COLOR="GOLD">
THERE ARE VARIOUS KIND OF LINKED LIST THAT EXIST IN 'C'. THESE ARE DESCRIBED BELOW
</FONT>

<OL>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
SINGLY LINKED LIST

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
DOUBLY LINKED LIST

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
CIRCULAR LINKED LIST

</OL>


<UL>
<FONT COLOR="PINK">
<U>
<LI> SINGLY LINKED LIST
</U>
</FONT>
</BR></BR>

IN <I>SINGLY LINKED LIST</I> TYPES OF LINKED LIST THAT EXISTS IN 'C'. THESE ARE DESCRIBED BELOW-:

</BR></BR>

<IMG SRC="SINGLY LINKED LIST.PNG" WIDTH="100%">

</BR></BR>

10, 3 AND 4 ARE THE DATA ITEMS AND THE LINKS ARE REPRESENTES BY ARROWS. THE ITEM AND THE LINK COMBINED TOGETHER ARE CALLED <I>NODE</I>. NULL REPRESENTS THAT THERE IS NO MORE LINK.

</BR></BR>

<FONT COLOR="PINK">
<U>
<LI> DOUBLY LINKED LIST
</U>
</FONT>
</BR></BR>

IN <I>DOUBLY  LINKED LIST</I>, EACH NODE CONTAINS DATA AND TWO LINKS, ONE TO PREVIOUS NODE AND ONE TO THE NEXT NODE. SINGLY CONNECTED LISTS CANNOT BE TRAVERSED IN BACKWARD MANNER, WITH THE SAME EASE AS FORWARD TRAVERSAL. HOWEVER, DOUBLY LINKED LIST CAN BE TRAVERSED FORWARD AND BACKWARD WITH EASE.

</BR></BR>

<IMG SRC="DOUBLY LINKED LIST.PNG" WIDTH="100%">

</BR></BR>

10, 20, 30 ARE THE DATA ITEMS AND THE LINKS ARE REPRESENTED BY ARROWS. IN EACH NODE, THERE ARE TWO LINKS, ONE REPRESENTING THE ADDRESS OF THE PREVIOUS ITEM AND THE OTHER THAT OF THE NEXT ITEM. NULL REPRESENTS THAT THERE IS NO MORE PREVIOUS OR NEXT ADDRESS.

</BR></BR>

<FONT COLOR="PINK">
<U>
<LI> CIRCULAR LINKED LIST
</U>
</FONT>
</BR></BR>

ONE OF THE SHORTCOMINGS OF A LINEAR LINKED LIST IS THAT HAVING REACHED TO THE LAST NODE IN THE LIST, WE CANNOT GO BACK TO PREVIOUS NODE UNLESS THE ADDRESS IS STORED. SUPPOSE WE MAKE A SMALL CHANGE IN THE STRUCTURE OF A LIST SO THAT THE NEXT ADDRESS FIELD OF THE LAST NODE IN THE LIST IS NOT NULL, BUT IS THE ADDRESS OF THE FIRST NODE OF THE LIST, THEN WE HAVE WHAT IS CALLED A <I>CIRCULAR LIST</I>. IN SUCH A STRUCTURE, WE CAN REACH ANY OTHER NODE IN THE LIST.

</BR></BR>

IN A CIRCULAR LINKED LIST, THE LAST NODE DOES NOT CONTAIN THE NULL POINTER. INSTEAD, IT CONTAINS THE POINTER OF THE FIRST NODE.

</BR></BR>

<IMG SRC="CIRCULAR LINKED LIST.PNG" WIDTH="100%">

</BR></BR>

</UL>































<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
POINTER
</U>
</FONT>
</BR></BR>

A <I>POINTER</I> IS A VARIABLE THAT HOLDS THE MEMORY ADDRESS OF ANOTHER VARIABLE.

</BR></BR>

ASTERISK (*) IS USED FOR TWO PURPOSE.

</BR></BR>

<OL>
<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
TO DECLARE A POINTER VARIABLE

<FONT COLOR="GOLD">
<LI>&nbsp;
</FONT>
TO DEREFERENCE A POINTER

</OL>


TO DECLARE A POINTER VARIABLE IS SIMILAR TO ANY OTHER VARIABLE AND MUST BE DECLARED BEFORE IT CAN BE USED. JUST LIKE, AN INTGER VARIABLE CAN HOLD ANY INTEGERS EACH POINTER VARIABLE CAN HOLD ONLY POINTER TO A SPECIFIC DATA TYPE, SUCH AS int, char, float, double, etc.

</BR></BR>

int *y;

</BR></BR>

y is a pointer to an integer

</BR></BR>

THE ASTERISK(*) PREFIXED TO THE VARIABLE NAME INDICATES THAT y IS A POINTER VARIABLE. THE DATA TYPE int TELLS THAT y CAN POINT TO ANY INTEGER TYPE ITEM, STORED IN THE MEMORY.

</BR></BR>

int x=2;</BR>
int *y;</BR>
y=&x;

</BR></BR>

THE *ASTERISK (INDIRECTION OPERATOR), IS A UNARY OPERATOR i.e. IT OPERATES ON ONE VARIABLE (SUCH AS y IN *y). * IS CALLED "VALUE AT ADDRESS" OPERATOR. IT RETURNS THE VALUE STORED AT A PARTICULAR ADDRESS. THE "VALUE AT ADDRESS" OPERATOR IS ALSO CALLED INDIRECTION OR DEREFERENCING OPERATOR.

</BR></BR>

#include < stdio.h ></BR>
main()</BR>
{</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	int x=2;</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	int *y;</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	y=&x;</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	printf("\n ADDRESS OF x= %u",&x);</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	printf("\n ADDRESS OF x= %u",y);</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	printf("\n ADDRESS OF y= %u",&y);</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	printf("\n VALUE OF y= %d",y);</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	printf("\n VALUE OF x= %d",x);</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	printf("\n VALUE OF x= %d",*(&x));</BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	printf("\n VALUE OF x= %d",*y);</BR>
}

</BR></BR>

<U>RUN</U></BR></BR>
ADDRESS OF x=6485</BR>
ADDRESS OF x=6485</BR>
ADDRESS OF y=3276</BR>
VALUE OF y=6485</BR>
VALUE OF x=2</BR>
VALUE OF x=2</BR>
VALUE OF x=2

</BR></BR>



</BR></BR>

































<IMG SRC="AG00092_.GIF" ALIGN="LEFT">
<FONT COLOR="BROWN" SIZE="5">
<U>
FILE HANDLING
</U>
</FONT>
</BR></BR>

A FILE REPRESENTS A SEQUENCE OF BYTES, DOES NOT MATTER IF IT IS A TEXT FILE OR BINARY FILE. C PROGRAMMING LANGUAGE PROVIDES ACCESS ON HIGH LEVEL FUNCTIONS AS WELL AS LOW LEVEL (OS LEVEL) CALLS TO HANDLE FILE ON YOUR STORAGE DEVICES.

</BR></BR>

YOU CAN USE THE fopen() FUNCTION TO CREATE A NEW FILE OR TO OPEN AN EXISTING FILE, THIS CALL WILL INITIALIZE AN OBJECT OF THE TYPE FILE, WHICH CONTAINS ALL THE INFORMATION NECESSARY TO CONTROL THE STREAM. FOLLOWING IS THE PROTOTYPE OF THIS FUNCTION CALL

</BR></BR>

FILE *fopen( const char * filename, const char *node);

</BR></BR>

HERE, FILENAME IS STRING LITERAL, WHICH YOU WILL USE TO NAME YOUR FILE AND ACCESS MODE CAN HAVE ONE OF THE FOLLOWING VALUES:

</BR></BR>

<TABLE WIDTH="100%" CELLSPACING="10">
<TR>
<TH WIDTH="12%">
<FONT COLOR="LIGHTGREEN">
FILE MODE
</FONT>
</TH>
<TH>
<FONT COLOR="LIGHTGREEN">
DESCRIPTION
</FONT>
</TH>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
r
</FONT>
</TH>
<TD>
OPENS AN EXISTING TEXT FILE FOR READING PURPOSE.
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
w
</FONT>
</TH>
<TD>
OPENS A TEXT FILE FOR WRITNG, IF IT DOES NOT EXIST THEN A NEW FILE IS CREATED. HERE YOUR PROGRAM WILL START WRITING CONTENT FROM THE BEGINNING OF THE FILE.
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
a
</FONT>
</TH>
<TD>
OPENS A TEXT FILE FOR WRITING IN APPENDING MODE, IF IT DOES NOT EXIST THEN A NEW FILE IS CREATED. HERE, YOUR PROGRAM WILL START APPENDING CONTENT IN THE EXISTING FILE CONTENT.
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
r+
</FONT>
</TH>
<TD>
OPENS A TEXT FILE FOR READING AND WRITING BOTH.
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
w+
</FONT>
</TH>
<TD>
OPENS A TEXT FILE FOR READING AND WRITING BOTH. IT FIRST TURNCATE THE FILE TO ZERO LENGTH IF IT EXISTS OTHERWISE CREATE THE FILE IF IT DOES NOT EXIST.
</TD>
</TR>
<TR>
<TH>
<FONT COLOR="GOLD">
a+
</FONT>
</TH>
<TD>
OPENS A TEXT FILE FOR READING AND WRITING BOTH. IT CREATES THE FILE IF IT DOES NOT EXIST. THE READING WILL START FROM THE BEGINNING BUT WRITING CAN ONLY BE APPENDED.
</TD>
</TR>
</TABLE>

</BR></BR>

<FONT COLOR="PINK">
<U>
CLOSING A FILE-:
</U>
</FONT>

</BR></BR>

TO CLOSE A FILE, USE THE fclose() FUNCTION. THE PROTOTYPE OF THIS FUNCTION IS:

</BR></BR>

int fclose( FILE *fp);

</BR></BR>

THE fclose() FUNCTION RETURNS ZERO ON SUCCESS OR EOF IF THERE IS AN ERROR IN CLOSING THE FILE. THIS FUNCTION ACTUALLY, FLUSHES ANY DATA STILL PENDING IN THE BUFFER TO THE FILE, CLOSES THE FILE AND RELEASES ANY MEMORY USED FOR THE FILE.

</BR></BR>


</FONT>
</B>
</BODY>
</HTML>